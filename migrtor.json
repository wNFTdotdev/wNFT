{"language": "Vyper", "sources": {"src/MigratorRouter.vy": {"content": "# pragma version ^0.4.3\n# Contract that handles compound actions on behalf of users\n# Covers the following use cases:\n# - Liquidity Management\n# - Wrapping/Unwrapping for staking reasons\n# - Batch actions\n\nfrom ethereum.ercs import IERC20 as ERC20\nfrom ethereum.ercs import IERC721 as ERC721\nfrom ethereum.ercs import IERC4626 as ERC4626\n\ninterface ERC721Enumerable:\n    def tokenOfOwnerByIndex(owner: address, index: uint256) -> uint256: view\n    def balanceOf(owner: address) -> uint256: view\n\ninterface RemyVault:\n    def mint(tokenId: uint256, recipient: address): nonpayable\n    def mint_batch(tokenIds: DynArray[uint256, 100], recipient: address, force_fee: bool) -> uint256: nonpayable\n    def redeem(tokenId: uint256, recipient: address): nonpayable\n    def redeem_batch(tokenIds: DynArray[uint256, 100], recipient: address, force_fee: bool) -> uint256: nonpayable\n    def onERC721Received(operator: address, _from: address, tokenId: uint256, data: Bytes[256]) -> bytes4: nonpayable\n    def transfer_owner(new_owner: address): nonpayable\n    def set_fees(fees: uint256[2]): nonpayable\n    def set_active(active: bool): nonpayable\n    def set_fee_exempt(exempt: address, is_exempt: bool): nonpayable\n    def set_rbtoken_fee_receiver(receiver: address): nonpayable\n    def erc20() -> address: view\n    def erc721() -> address: view\n    def active() -> bool: view\n    def owner() -> address: view\n    def mint_fee() -> uint256: view\n    def redeem_fee() -> uint256: view\n    def rbtoken_fee_receiver() -> address: view\n    def fee_exempt(arg0: address) -> bool: view\n    def quote_redeem(count: uint256, force_fee: bool) -> uint256: view\n    def quote_mint(count: uint256, force_fee: bool) -> uint256: view\n    def quote_redeem_fee(recipient: address, num_tokens: uint256) -> uint256: view\n    def quote_mint_fee(recipient: address, num_tokens: uint256) -> uint256: view\n    def charge_fee(amt: uint256): nonpayable\n\ninterface RemyVaultV2:\n    def deposit(tokenIds: DynArray[uint256, 100], recipient: address) -> uint256: nonpayable\n    def withdraw(tokenIds: DynArray[uint256, 100], recipient: address) -> uint256: nonpayable\n    def quoteDeposit(count: uint256) -> uint256: view\n    def quoteWithdraw(count: uint256) -> uint256: view\n    def erc20() -> address: view\n\ninterface DN404:\n    def setSkipNFT(skip: bool) -> bool: nonpayable\n\ninterface WETH9:\n    def deposit(): payable\n    def withdraw(amount: uint256): nonpayable\n    def balanceOf(account: address) -> uint256: view\n\nstruct ExactInputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    fee: uint24\n    recipient: address\n    amountIn: uint256\n    amountOutMinimum: uint256\n    sqrtPriceLimitX96: uint160\n\nstruct ExactOutputSingleParams:\n    tokenIn: address\n    tokenOut: address\n    fee: uint24\n    recipient: address\n    amountOut: uint256\n    amountInMaximum: uint256\n    sqrtPriceLimitX96: uint160\n\n# v3 router interface\ninterface SwapRouter:\n    def exactInputSingle(params: ExactInputSingleParams) -> uint256: payable\n    def exactOutputSingle(params: ExactOutputSingleParams) -> uint256: payable\n\n# going to store some addresses in storage to avoid passing them around\nowner: public(address)\nvault_address: public(address)\nrouter_address: public(address)\nweth: public(address)\nv3router_address: public(address)\nerc4626_address: public(address)\nerc721_address: public(address)\nerc20_address: public(address)\nvault_v2_address: public(address)\nerc20_v2_address: public(address)\nfee_privileged: public(address)\n\ninterface OldRouter:\n    def vault_address() -> address: view\n    def weth() -> address: view\n    def v3router_address() -> address: view\n    def erc4626_address() -> address: view\n\n@deploy\ndef __init__(old_router: address, vault_v2: address):\n    self.owner = msg.sender\n    self.vault_address = staticcall OldRouter(old_router).vault_address()\n    self.weth = staticcall OldRouter(old_router).weth()\n    self.v3router_address = staticcall OldRouter(old_router).v3router_address()\n    self.erc4626_address = staticcall OldRouter(old_router).erc4626_address()\n    self.erc721_address = staticcall RemyVault(self.vault_address).erc721()\n    self.erc20_address = staticcall RemyVault(self.vault_address).erc20()\n    self.vault_v2_address = vault_v2\n    self.erc20_v2_address = staticcall RemyVaultV2(vault_v2).erc20()\n\n    # approve vault for all erc721 transfers\n    extcall ERC721(self.erc721_address).setApprovalForAll(self.vault_address, True)\n    extcall ERC721(self.erc721_address).setApprovalForAll(self.vault_v2_address, True)\n\n@external\ndef stake_inventory(recipient: address, token_ids: DynArray[uint256, 100]):\n    \"\"\"\n    Stakes an NFT in the vault\n    \"\"\"\n    vault: RemyVault = RemyVault(self.vault_address)\n    extcall vault.set_active(True)\n    nft: ERC721 = ERC721(self.erc721_address)\n    nft_token: ERC20 = ERC20(self.erc20_address)\n    erc4626: ERC4626 = ERC4626(self.erc4626_address)\n    for token_id: uint256 in token_ids:\n        extcall nft.transferFrom(msg.sender, self, token_id)\n    extcall DN404(nft_token.address).setSkipNFT(True)\n    minted: uint256 = extcall vault.mint_batch(token_ids, self, False)\n    extcall nft_token.approve(self.erc4626_address, minted)\n    extcall erc4626.deposit(minted, recipient)\n    extcall vault.set_active(False)\n\n@external\ndef unstake_inventory(recipient: address, token_ids: DynArray[uint256, 100]):\n    \"\"\"\n    Unstakes an NFT from the vault\n    \"\"\"\n    vault: RemyVault = RemyVault(self.vault_address)\n    extcall vault.set_active(True)\n    nft: ERC721 = ERC721(self.erc721_address)\n    nft_token: ERC20 = ERC20(self.erc20_address)\n    erc4626: ERC4626 = ERC4626(self.erc4626_address)\n    start_bal: uint256 = staticcall ERC20(self.erc4626_address).balanceOf(self)\n    tokens_required: uint256 = staticcall vault.quote_redeem(len(token_ids), False)\n    shares_required: uint256 = staticcall erc4626.convertToShares(tokens_required) + 1\n    extcall ERC20(self.erc4626_address).transferFrom(msg.sender, self, shares_required)\n    extcall erc4626.withdraw(tokens_required, self, self)\n    extcall nft_token.approve(self.vault_address, tokens_required)\n    extcall vault.redeem_batch(token_ids, recipient, False)\n    if staticcall ERC20(self.erc4626_address).balanceOf(self) > start_bal:\n        extcall ERC20(self.erc4626_address).transfer(recipient, staticcall ERC20(self.erc4626_address).balanceOf(self) - start_bal)\n    extcall vault.set_active(False)\n\n@internal\ndef wrap_eth(amount: uint256):\n    \"\"\"\n    Wraps ETH into WETH\n    \"\"\"\n    extcall WETH9(self.weth).deposit(value=amount)\n\n@internal\ndef unwrap_eth(amount: uint256):\n    \"\"\"\n    Unwraps WETH into ETH\n    \"\"\"\n    extcall WETH9(self.weth).withdraw(amount)\n\n@internal\ndef _ensure_fee_exempt(vault: RemyVault):\n    \"\"\"\n    Ensures the router is marked fee exempt on the provided vault when it controls ownership\n    \"\"\"\n    if staticcall vault.owner() == self:\n        if not staticcall vault.fee_exempt(self):\n            extcall vault.set_fee_exempt(self, True)\n\n@internal\ndef swap_erc20_for_weth(amountIn: uint256) -> uint256:\n    \"\"\"\n    Swaps ERC20 tokens for WETH\n    \"\"\"\n    router: SwapRouter = SwapRouter(self.v3router_address)\n    token: ERC20 = ERC20(self.erc20_address)\n    params: ExactInputSingleParams = ExactInputSingleParams(\n        tokenIn = self.erc20_address,\n        tokenOut = self.weth,\n        fee = 3000,\n        recipient = self,\n        amountIn = amountIn,\n        amountOutMinimum = 0,\n        sqrtPriceLimitX96 = 0\n    )\n    extcall token.approve(self.v3router_address, amountIn)\n    return_val: uint256 = extcall router.exactInputSingle(params)\n    log ERC20SwappedForWETH(swapper=msg.sender, amountIn=amountIn, amountOut=return_val)\n    return return_val\n\nevent ERC20SwappedForWETH:\n    swapper: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n\nevent WETHSwappedForERC20:\n    swapper: indexed(address)\n    amountIn: uint256\n    amountOut: uint256\n\n@payable\n@internal\ndef swap_weth_for_erc20(amountOut: uint256) -> uint256:\n    \"\"\"\n    Swaps WETH for ERC20 tokens\n    \"\"\"\n    router: SwapRouter = SwapRouter(self.v3router_address)\n    token: ERC20 = ERC20(self.erc20_address)\n    params: ExactOutputSingleParams = ExactOutputSingleParams(\n        tokenIn = self.weth,\n        tokenOut = self.erc20_address,\n        fee = 3000,\n        recipient = self,\n        amountOut = amountOut,\n        amountInMaximum = msg.value,\n        sqrtPriceLimitX96 = 0\n    )\n    extcall ERC20(self.weth).approve(self.v3router_address, msg.value)\n    return_val: uint256 = extcall router.exactOutputSingle(params)\n    log WETHSwappedForERC20(swapper=msg.sender, amountIn=msg.value, amountOut=return_val)\n    return return_val\n\n@payable\n@external\ndef swap_eth_for_nft_v3(tokenIds: DynArray[uint256, 100], recipient: address):\n    \"\"\"\n    Swaps ETH for an NFT using the v3 router\n    \"\"\"\n    router: SwapRouter = SwapRouter(self.v3router_address)\n    vault: RemyVault = RemyVault(self.vault_address)\n    extcall vault.set_active(True)\n    token: ERC20 = ERC20(self.erc20_address)\n    min_out: uint256 = staticcall vault.quote_redeem(len(tokenIds), True)\n    extcall WETH9(self.weth).deposit(value=msg.value)\n    self.swap_weth_for_erc20(min_out)\n    assert self.vault_address != empty(address), \"vault address not set\"\n    extcall token.approve(self.vault_address, min_out)\n    extcall vault.redeem_batch(tokenIds, recipient, True)\n    extcall vault.set_active(False)\n\n@external\ndef swap_nft_for_eth_v3(tokenIds: DynArray[uint256, 100], min_out: uint256, recipient: address):\n    \"\"\"\n    Swaps an NFT for ETH using the v3 router\n    \"\"\"\n    router: SwapRouter = SwapRouter(self.v3router_address)\n    vault: RemyVault = RemyVault(self.vault_address)\n    extcall vault.set_active(True)\n    token: ERC20 = ERC20(self.erc20_address)\n    nft: ERC721 = ERC721(self.erc721_address)\n    for token_id: uint256 in tokenIds:\n        extcall nft.transferFrom(msg.sender, self, token_id)\n    extcall DN404(token.address).setSkipNFT(True)\n    minted_amt: uint256 = extcall vault.mint_batch(tokenIds, self, True)\n    extcall token.approve(self.v3router_address, staticcall token.balanceOf(self))\n    weth_balance_before: uint256 = staticcall WETH9(self.weth).balanceOf(self)\n    params: ExactInputSingleParams = ExactInputSingleParams(\n        tokenIn = self.erc20_address,\n        tokenOut = self.weth,\n        fee = 3000,\n        recipient = self,\n        amountIn = minted_amt,\n        amountOutMinimum = 0,\n        sqrtPriceLimitX96 = 0\n    )\n    extcall router.exactInputSingle(params)\n    weth_balance_after: uint256 = staticcall WETH9(self.weth).balanceOf(self)\n    extcall WETH9(self.weth).withdraw(weth_balance_after - weth_balance_before)\n    send(recipient, weth_balance_after - weth_balance_before)\n    extcall vault.set_active(False)\n\nevent NFTsSwappedForNFTs:\n    swapper: indexed(address)\n    nfts_in_count: uint256\n    nfts_out_count: uint256\n    fee: uint256\n    proceeds: uint256\n\nevent MintFeeCharged:\n    swapper: indexed(address)\n    recipient: indexed(address)\n    fee: uint256\n\nevent RedeemFeeCharged:\n    swapper: indexed(address)\n    recipient: indexed(address)\n    fee: uint256\n\nevent SaleProceeds:\n    swapper: indexed(address)\n    proceeds: uint256\n\nevent WethRefunded:\n    swapper: indexed(address)\n    proceeds: uint256\n\nevent TokensSwappedForNFTs:\n    swapper: indexed(address)\n    tokens_in: uint256\n    nfts_out_count: uint256\n    fee: uint256\n\nevent V2TokensSwappedForV1NFTs:\n    swapper: indexed(address)\n    tokens_in: uint256\n    nfts_supplied_count: uint256\n    nfts_out_count: uint256\n    leftover_tokens: uint256\n\nevent V1TokensConvertedToV2:\n    swapper: indexed(address)\n    tokens_in: uint256\n    tokens_out: uint256\n    minted: uint256\n    buffer_used: uint256\n\n@view\n@external\ndef quote_swap_in_tokens(tokenIds_in: DynArray[uint256, 100], tokenIds_out: DynArray[uint256, 100]) -> uint256:\n    \"\"\"\n    Quotes the amount of tokens required to be bought to swap NFTs for NFTs\n    Tokens are required to pay for the redeem fee on swaps\n    \"\"\"\n    if len(tokenIds_in) > len(tokenIds_out):\n        return 0\n    vault: RemyVault = RemyVault(self.vault_address)\n    total_tokens_required: uint256 = 0\n    mint_fee: uint256 = 0\n    num_swaps: uint256 = min(len(tokenIds_in), len(tokenIds_out))\n    num_bought: uint256 = len(tokenIds_out) - num_swaps\n    num_sold: uint256 = len(tokenIds_in) - num_swaps\n    if num_bought > 0:\n        mint_fee = staticcall vault.quote_mint_fee(msg.sender, num_bought)\n    force_fee: bool = True\n    if msg.sender == self.fee_privileged:\n        force_fee = False\n    total_tokens_required = staticcall vault.quote_redeem(len(tokenIds_out), force_fee)\n    total_tokens_minted: uint256 = staticcall vault.quote_mint(len(tokenIds_in), False)\n    if mint_fee > 0:\n        total_tokens_required += mint_fee\n    if total_tokens_minted < total_tokens_required:\n        return total_tokens_required - total_tokens_minted\n    return 0\n\n# function that takes in a list of tokenIds being bought, a list of tokenIds being sold, and the recipient\n# the contract should calculate any eth payment required and charge the user\n# if instead there are more in than out, the contract should calculate the amount of eth to send back\n# steps:\n# 1. transfer the NFTs to the contract\n# 2. mint token with the vault\n# 3. calculate the amount of tokens required to redeem the NFTs\n# 4a. if the user has enough tokens, go to step 5\n# 4b. if the user does not have enough tokens, swap eth for the required amount of tokens\n# 5. approve the vault to spend the tokens\n# 6. redeem the desired NFTs with the tokens\n# 7. transfer the NFTs to the recipient\n# 8. if there are tokens left over, sell them for eth and send the eth to the user\n# nfts swapped for nfts dont have to pay the mint fee, everything gets charged the redeem fee\n@payable\n@external\ndef swap(tokenIds_in: DynArray[uint256, 100], tokenIds_out: DynArray[uint256, 100], recipient: address):\n    \"\"\"\n    Swaps NFTs for NFTs by redeeming the NFTs for 1000 ERC20 tokens and swapping them for the target NFT\n    \"\"\"\n    # get the vault, nft, and token contracts\n    vault: RemyVault = RemyVault(self.vault_address)\n    extcall vault.set_active(True)\n    nft: ERC721 = ERC721(self.erc721_address)\n    token: ERC20 = ERC20(self.erc20_address)\n\n    # initialize state we will use throughout\n    total_tokens_to_sell: uint256 = 0 # erc20 tokens not needed for redeem\n    total_tokens_to_buy: uint256 = 0\n\n    # don't blindly trust user balances\n    # in case of reentrancy could be an issue\n    # instead we check balance before and after batch_mint\n    bal_before: uint256 = staticcall token.balanceOf(self)\n    bal_after: uint256 = 0\n\n    # transfer the NFTs to the contract\n    for token_id: uint256 in tokenIds_in:\n        extcall nft.transferFrom(msg.sender, self, token_id)\n\n    # calculate how many are nft-nft swaps\n    num_swaps: uint256 = min(len(tokenIds_in), len(tokenIds_out))\n\n    # num_bought is the number of nfts that the user is buying\n    # beyond the nft-nft swaps and should be charged the full fee\n    num_bought: uint256 = len(tokenIds_out)\n    num_bought -= num_swaps\n\n    # num_sold is the number of nfts that the user is selling\n    # beyond the nft-nft swaps and should be charged the full fee\n    num_sold: uint256 = len(tokenIds_in)\n    num_sold -= num_swaps\n\n    extcall DN404(token.address).setSkipNFT(True)\n    amt_minted: uint256 = 0\n\n    if len(tokenIds_in) > 0:\n        amt_minted = extcall vault.mint_batch(tokenIds_in, self, False)\n\n    bal_after = staticcall token.balanceOf(self)\n\n    assert bal_after - bal_before == amt_minted, \"minted amount does not match\"\n\n    # TODO: this is a bug, we don't mint the ERC20 on *buys*, only on sells, buys only involve redeeming\n    # charge fees on num_bought nfts, this is the only time we charge mint fees\n    # this avoids bvpassing the mint fee through this swap method\n    mint_fee: uint256 = 0\n    if num_sold > 0:\n        mint_fee = staticcall vault.quote_mint_fee(recipient, num_sold)\n\n    force_fee: bool = True\n    if msg.sender == self.fee_privileged:\n        force_fee = False\n    total_tokens_required: uint256 = staticcall vault.quote_redeem(len(tokenIds_out), force_fee)\n    if mint_fee > 0:\n        total_tokens_required += mint_fee\n        log MintFeeCharged(swapper=msg.sender, recipient=recipient, fee=mint_fee)\n\n    if amt_minted < total_tokens_required:\n        total_tokens_to_buy = total_tokens_required - amt_minted\n\n    if total_tokens_to_buy > 0:\n        weth_balance_before: uint256 = staticcall WETH9(self.weth).balanceOf(self)\n        extcall WETH9(self.weth).deposit(value=msg.value)\n        self.swap_weth_for_erc20(total_tokens_to_buy)\n        # charge mint fee we calculated earlier\n        if mint_fee > 0:\n            extcall token.approve(self.vault_address, staticcall token.balanceOf(self))\n            extcall vault.charge_fee(mint_fee)\n        weth_balance_after: uint256 = staticcall WETH9(self.weth).balanceOf(self)\n        # if we have leftover weth, send it back\n        # it was provided as eth so we unwrap it\n        if weth_balance_after > weth_balance_before:\n            diff: uint256 = weth_balance_after - weth_balance_before\n            extcall WETH9(self.weth).withdraw(diff)\n            send(msg.sender, diff)\n            log WethRefunded(swapper=msg.sender, proceeds=diff)\n    extcall token.approve(self.vault_address, staticcall token.balanceOf(self))\n    amt_redeemed: uint256 = extcall vault.redeem_batch(tokenIds_out, recipient, force_fee)\n    amt_leftover: uint256 = 0\n    if amt_minted > amt_redeemed:\n        amt_leftover = amt_minted - amt_redeemed\n\n    # return leftover erc20 tokens to the user as eth\n    if amt_leftover > 0:\n        extcall token.approve(self.v3router_address, amt_leftover)\n        swap_amt: uint256 = self.swap_erc20_for_weth(amt_leftover)\n        extcall WETH9(self.weth).withdraw(swap_amt)\n        send(msg.sender, swap_amt)\n        log SaleProceeds(swapper=msg.sender, proceeds=swap_amt)\n\n    log NFTsSwappedForNFTs(swapper=recipient, nfts_in_count=len(tokenIds_in), nfts_out_count=len(tokenIds_out), fee=mint_fee, proceeds=amt_leftover)\n    extcall vault.set_active(False)\n\n@external\ndef swap_tokens_for_nfts(tokenIds: DynArray[uint256, 100], recipient: address):\n    \"\"\"\n    Swaps vault tokens for NFTs directly, without requiring ETH payment\n    User must have approved this contract to spend their tokens\n    \"\"\"\n    vault: RemyVault = RemyVault(self.vault_address)\n    extcall vault.set_active(True)\n    token: ERC20 = ERC20(self.erc20_address)\n    \n    # Calculate total tokens required (including redeem fee)\n    tokens_required: uint256 = staticcall vault.quote_redeem(len(tokenIds), False)\n    \n    # Transfer tokens from user to this contract\n    extcall token.transferFrom(msg.sender, self, tokens_required)\n    \n    # Approve vault to spend the tokens\n    extcall token.approve(self.vault_address, tokens_required)\n    \n    # Redeem the NFTs\n    amt_redeemed: uint256 = extcall vault.redeem_batch(tokenIds, recipient, False)\n    \n    # Log the transaction\n    log TokensSwappedForNFTs(swapper=msg.sender, tokens_in=tokens_required, nfts_out_count=len(tokenIds), fee=tokens_required - (len(tokenIds) * 1000))\n    \n    extcall vault.set_active(False)\n\n@external\ndef swap_vault_tokens_for_nfts(tokenIds_v2: DynArray[uint256, 100], tokenIds_v1: DynArray[uint256, 100], recipient: address):\n    \"\"\"\n    Redeems Vault V2 inventory directly and sources Vault V1 NFTs via swap using additional V2 redemptions\n    Caller must approve the MigratorRouter to spend the required ERC20 V2 amount\n    \"\"\"\n    total_targets: uint256 = len(tokenIds_v2) + len(tokenIds_v1)\n    assert total_targets > 0, \"no target NFTs provided\"\n\n    vault_v1: RemyVault = RemyVault(self.vault_address)\n    vault_v2: RemyVaultV2 = RemyVaultV2(self.vault_v2_address)\n    token_v1: ERC20 = ERC20(self.erc20_address)\n    token_v2: ERC20 = ERC20(self.erc20_v2_address)\n    nft: ERC721 = ERC721(self.erc721_address)\n\n    self._ensure_fee_exempt(vault_v1)\n\n    tokens_required_direct: uint256 = staticcall vault_v2.quoteWithdraw(len(tokenIds_v2))\n    tokens_required_supply: uint256 = staticcall vault_v2.quoteWithdraw(len(tokenIds_v1))\n    tokens_required_total: uint256 = tokens_required_direct + tokens_required_supply\n\n    extcall token_v2.transferFrom(msg.sender, self, tokens_required_total)\n\n    tokens_burned_total: uint256 = 0\n    leftover_tokens: uint256 = 0\n\n    if len(tokenIds_v2) > 0:\n        extcall token_v2.approve(self.vault_v2_address, tokens_required_direct)\n        burned_direct: uint256 = extcall vault_v2.withdraw(tokenIds_v2, recipient)\n        tokens_burned_total += burned_direct\n\n    if len(tokenIds_v1) > 0:\n        nft_enum: ERC721Enumerable = ERC721Enumerable(self.erc721_address)\n        available_v2: uint256 = staticcall nft_enum.balanceOf(self.vault_v2_address)\n        assert available_v2 >= len(tokenIds_v1), \"insufficient V2 inventory\"\n\n        supply_tokenIds: DynArray[uint256, 100] = []\n        for idx: uint256 in range(available_v2, bound=1000):\n            candidate: uint256 = staticcall nft_enum.tokenOfOwnerByIndex(self.vault_v2_address, idx)\n            supply_tokenIds.append(candidate)\n            if len(supply_tokenIds) == len(tokenIds_v1):\n                break\n        assert len(supply_tokenIds) == len(tokenIds_v1), \"insufficient V2 supply for swap\"\n\n        extcall token_v2.approve(self.vault_v2_address, tokens_required_supply)\n        tokens_burned_supply: uint256 = extcall vault_v2.withdraw(supply_tokenIds, self)\n        tokens_burned_total += tokens_burned_supply\n\n        extcall vault_v1.set_active(True)\n        bal_before_v1: uint256 = staticcall token_v1.balanceOf(self)\n        extcall DN404(token_v1.address).setSkipNFT(True)\n        amt_minted_v1: uint256 = extcall vault_v1.mint_batch(supply_tokenIds, self, False)\n        bal_after_v1: uint256 = staticcall token_v1.balanceOf(self)\n        assert bal_after_v1 - bal_before_v1 == amt_minted_v1, \"minted V1 token mismatch\"\n\n        tokens_needed_v1: uint256 = staticcall vault_v1.quote_redeem(len(tokenIds_v1), False)\n        assert amt_minted_v1 >= tokens_needed_v1, \"insufficient legacy liquidity\"\n        extcall token_v1.approve(self.vault_address, amt_minted_v1)\n        amt_redeemed_v1: uint256 = extcall vault_v1.redeem_batch(tokenIds_v1, recipient, False)\n\n        if amt_minted_v1 > amt_redeemed_v1:\n            leftover_tokens = amt_minted_v1 - amt_redeemed_v1\n            extcall token_v1.transfer(recipient, leftover_tokens)\n\n        extcall vault_v1.set_active(False)\n\n    assert tokens_burned_total == tokens_required_total, \"vault v2 withdrawal mismatch\"\n\n    log V2TokensSwappedForV1NFTs(\n        swapper=msg.sender,\n        tokens_in=tokens_required_total,\n        nfts_supplied_count=len(tokenIds_v1),\n        nfts_out_count=len(tokenIds_v1) + len(tokenIds_v2),\n        leftover_tokens=leftover_tokens\n    )\n\n@external\ndef onERC721Received(operator: address, from_addr: address, tokenId: uint256, data: Bytes[256]) -> bytes4:\n    \"\"\"\n    Accept ERC721 transfers required for migration flows\n    \"\"\"\n    return 0x150b7a02\n\n@external\ndef convert_v1_tokens_to_v2(tokenIds: DynArray[uint256, 100], recipient: address):\n    \"\"\"\n    Converts Vault V1 ERC20 into Vault V2 ERC20 by cycling through the shared NFT inventory\n    Caller must approve the required V1 tokens prior to invoking\n    \"\"\"\n    assert len(tokenIds) > 0, \"no NFTs specified\"\n\n    vault_v1: RemyVault = RemyVault(self.vault_address)\n    vault_v2: RemyVaultV2 = RemyVaultV2(self.vault_v2_address)\n    token_v1: ERC20 = ERC20(self.erc20_address)\n    token_v2: ERC20 = ERC20(self.erc20_v2_address)\n\n    self._ensure_fee_exempt(vault_v1)\n\n    tokens_required: uint256 = staticcall vault_v1.quote_redeem(len(tokenIds), False)\n    assert tokens_required > 0, \"invalid conversion size\"\n\n    extcall token_v1.transferFrom(msg.sender, self, tokens_required)\n    extcall vault_v1.set_active(True)\n    extcall token_v1.approve(self.vault_address, tokens_required)\n    extcall vault_v1.redeem_batch(tokenIds, self, False)\n\n    minted_v2: uint256 = extcall vault_v2.deposit(tokenIds, self)\n\n    total_balance_v2: uint256 = staticcall token_v2.balanceOf(self)\n    assert total_balance_v2 >= tokens_required, \"insufficient V2 liquidity\"\n    extcall token_v2.transfer(recipient, tokens_required)\n\n    buffer_used: uint256 = 0\n    if minted_v2 < tokens_required:\n        buffer_used = tokens_required - minted_v2\n\n    log V1TokensConvertedToV2(\n        swapper=msg.sender,\n        tokens_in=tokens_required,\n        tokens_out=tokens_required,\n        minted=minted_v2,\n        buffer_used=buffer_used\n    )\n\n    extcall vault_v1.set_active(False)\n\n@view\n@external\ndef quote_tokens_for_nfts(tokenIds: DynArray[uint256, 100]) -> uint256:\n    \"\"\"\n    Returns the amount of vault tokens required to redeem the specified NFTs\n    Includes any applicable redeem fees\n    \"\"\"\n    vault: RemyVault = RemyVault(self.vault_address)\n    return staticcall vault.quote_redeem(len(tokenIds), False)\n\n@view\n@external\ndef quote_v2_tokens_for_v1_nfts(num_nfts: uint256) -> uint256:\n    \"\"\"\n    Returns the amount of ERC20 V2 required to source the requested number of Vault V1 NFTs\n    \"\"\"\n    return staticcall RemyVaultV2(self.vault_v2_address).quoteWithdraw(num_nfts)\n\n@view\n@external\ndef quote_convert_v1_tokens_to_v2(tokenIds: DynArray[uint256, 100]) -> uint256:\n    \"\"\"\n    Helper for frontends to determine the Vault V1 token burn required for conversion\n    \"\"\"\n    return staticcall RemyVault(self.vault_address).quote_redeem(len(tokenIds), False)\n\n@external\ndef transfer_owner(new_owner: address):\n    assert msg.sender == self.owner\n    self.owner = new_owner\n\n@external\ndef transfer_vault_ownership(new_owner: address):\n    assert msg.sender == self.owner\n    extcall RemyVault(self.vault_address).transfer_owner(new_owner)\n\n@external\ndef set_fee_privileged(privileged: address):\n    assert msg.sender == self.owner\n    self.fee_privileged = privileged\n\n@payable\n@external\ndef __default__():\n    pass\n", "sha256sum": "caaa020da48a21464ed2867bab8ccb13167b4191d6263aed22affa31d9db0baa"}}, "settings": {"outputSelection": {"src/MigratorRouter.vy": ["*"]}, "search_paths": ["."]}, "compiler_version": "v0.4.3+commit.bff19ea2", "integrity": "84c589de8b69b2ecacc3b541483884786302b9d71bf11b0e89388c6a20486891"}
